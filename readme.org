* About

A permissively licensed modern implementation of Gauss-Jacobi quadrature which returns the weights and nodes over the standard interval $[-1, 1]$.
** Usage
The most automated approach is to use the ~conda~ environment and ~fpm~ build:
#+begin_src bash
micromamba create -f environment.yml
micromamba activate gaussjacquad
fpm build
#+end_src

An analytic result can be obtained from the ~scripts~ folder.
#+begin_src bash
python scripts/gen_analytic_vals.py --npts <npoints> --alpha <alpha> --beta <beta> --n_dig <precision>
fpm test
#+end_src

Running the implemented recursion based Gauss-Jacobi can be done via:
#+begin_src bash
fpm run gjp_quad_rec -- <npoints> <alpha> <beta>
fpm run gjp_quad -- <npoints> <alpha> <beta> <method>
#+end_src

Currently the only supported methods are "recurrence" and "gw" (Golub Welsch).
*** Meson Support
A ~meson~ build backend is also present, which makes it easier to incorporate as subprojects of projects other than those supported by ~fpm~.

#+begin_src bash
meson setup bbdir
meson compile -C bbdir
./bbdir/gjp_quad <npoints> <alpha> <beta> <method>
#+end_src

*** Interfaces
*** ~C~ Header
We provide a header only interface, which bypasses passing strings between
Fortran and C. In order to do this, there is some duplication logic in
~GaussJacobiQuad~ and ~GaussJacobiQuadCInterp~.

There is also a CLI interface to the ~C~ bound interface, ~c_cli_gjpq~. However,
this will not be compiled by ~fpm~.

#+begin_src bash
meson setup bbdir
meson compile -C bbdir
./bbdir/c_cli_gjpq <npoints> <alpha> <beta> <method>
#+end_src

The ~C~ CLI might be more pleasant in that decimals do not need to be provided
explicitly for ~alpha~ and ~beta~.
*** ~f2py~ generated interface
The ~ISO_C_ENVIRONMENT~ variant of the code is also used for a ~python~
interface generated with ~f2py~. It is easiest to use with the new ~meson~ back-end:
#+begin_src bash
cd interfaces/PyInterface
f2py -c --backend meson gjquadpy.pyf ../../src/GaussJacobiQuadCCompat.f90 \
../../src/GaussJacobiQuad.f90 ../../src/gjp_constants.f90 ../../src/gjp_gw.f90 \
../../src/gjp_lapack.f90 ../../src/gjp_rec.f90 ../../src/gjp_types.f90 \
deps: lapack :
#+end_src
Once compiled, the ~gjpquad_cli.py~ script can be used to run the code:
#+begin_src bash
python gjquad_cli.py --npts 5 --alpha 2 --beta 3
Root: -6.90457750126761027E-01 Weight: 2.74101780663370022E-02
Root: -3.26519931349000647E-01 Weight: 2.12917860603648035E-01
Root:  8.23378495520349085E-02 Weight: 4.39084379443950568E-01
Root:  4.75178870612831761E-01 Weight: 3.22206565472217876E-01
Root:  7.92794294644228348E-01 Weight: 6.50476830805121059E-02
#+end_src

** Notes
The ~recurrence~ method fails for high values of ~beta~ so the ~gw~ method
should be used in such situations.
** Benchmarks
A very preliminary set can be run once all the interfaces have been compiled:
#+begin_src bash
# From $GITROOT
mv interfaces/PyInterface/gjquadpy*.so .
hyperfine --warmup 3 --export-markdown gjp_benchmarks.md \
    'bbdir/gjp_quad 5 2. 3. "gw"' \
    'bbdir/c_cli_gjpq 5 2 3 gw' \
    'PYTHONPATH=$(pwd) python interfaces/PyInterface/gjquad_cli.py --npts 5 --alpha 2 --beta 3' \
    'python scripts/gen_analytic_vals.py --npts 5 --alpha 2 --beta 3 --n_dig 15'
#+end_src

Which gives:
#+begin_src bash
Summary
  bbdir/gjp_quad 5 2. 3. "gw" ran
    1.00 ± 0.44 times faster than bbdir/c_cli_gjpq 5 2 3 gw
   40.30 ± 13.43 times faster than PYTHONPATH=$(pwd) python interfaces/PyInterface/gjquad_cli.py --npts 5 --alpha 2 --beta 3
   88.42 ± 28.08 times faster than python scripts/gen_analytic_vals.py --npts 5 --alpha 2 --beta 3 --n_dig 15
hyperfine --warmup 3 --export-markdown gjp_benchmarks.md      17.61s user 29.06s system 357% cpu 13.056 total
#+end_src

Or in other words:
| Command                                                       | Mean [ms]   | Min [ms] | Max [ms] | Relative      |
|---------------------------------------------------------------+-------------+----------+----------+---------------|
| ~gjp_quad 5 2. 3. "gw"~                                       | 2.5 ± 0.8   |      1.7 |      6.6 | 1.00          |
| ~c_cli_gjpq 5 2 3 gw~                                         | 2.5 ± 0.8   |      1.7 |      7.4 | 1.00 ± 0.44   |
| ~gjquad_cli.py --npts 5 --alpha 2 --beta 3~                   | 99.8 ± 10.2 |     95.2 |    146.3 | 40.30 ± 13.43 |
| ~gen_analytic_vals.py --npts 5 --alpha 2 --beta 3 --n_dig 15~ | 219.0 ± 3.3 |    216.4 |    224.2 | 88.42 ± 28.08 |

Which suggests what one might suspect, that there is a large overhead in calling
~python~ , and that the ~C~ and ~Fortran~ variants are almost exactly as fast as
each other.
** Development
*** Developing locally
A ~pre-commit~ job is setup on CI to enforce consistent styles, so it is best to
set it up locally as well (using [[https://pypa.github.io/pipx][pipx]] for isolation):

#+begin_src sh
# Run before commiting
pipx run pre-commit run --all-files
# Or install the git hook to enforce this
pipx run pre-commit install
#+end_src
*** Updating licenses
When the headers in the sources need to be updated modify ~add_headers.py~ and run:
#+begin_src sh
python scripts/add_headers.py --dirs src/ interfaces/ --ftypes "f90,c,h"
#+end_src
Remember to do this before exporting the code into other projects (e.g. [[https://github.com/atomic-solvers/featom][featom]]).
* License
MIT.
